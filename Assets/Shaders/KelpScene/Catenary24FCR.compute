#pragma kernel Set
#pragma kernel Force
#pragma kernel Constraint
#pragma kernel Resolve

#include "../Chunks/noise.cginc"
#include "../Chunks/snoise.cginc"
#include "../Chunks/curlNoise.cginc"


float4x4 transform; 

float _Delta;
float _Time;
uint _Pass;
float _SpringDistance;

uint _NumVertsPerHair;
uint _HairsPerPoint;
float _BunchOutForce;
float _HairLength;
float _UpForce;
float _HairVariance;

float3 _HandL;
float3 _HandR;

struct Vert{
  float3 pos;
  float3 oPos;
  float3 nor;
  float3 tan;
  float2 uv;
  float  length;
  float debug;
};


struct Base{
  float3 pos;
  float3 vel;
  float3 nor;
  float3 tang;
  float2 uv;
  float used;
  float3 triIDs;
  float3 triWeights;
  float3 debug;
};


struct Bone{
  float3 start;
  float3 end;
  float  size;
  float  id;
};


float _NormalForce;
float _NoiseForce;
float _NoiseSpeed;
float _NoiseSize;
float _Dampening;

RWStructuredBuffer<Vert> _VertBuffer;
RWStructuredBuffer<Base> _BaseBuffer;

uint _VertBuffer_COUNT;
uint _BaseBuffer_COUNT;
uint _Pullers_COUNT;

#include "../Chunks/terrainCompute.cginc"


#include "../Chunks/safeID.cginc"

float3 getVel( float3 p1 , float3 p2 ){
  float3 v = p1 - p2;
  //if( length(v) > .5 ){ v = normalize(v) * .5;}
  if( length(v) > .5 ){ v = 0;}
  return v;
}

#include "../Chunks/springForce.cginc"


#define NR_THREADS 128

[numthreads(NR_THREADS,1,1)]
void Set (uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID, uint3 id : SV_DispatchThreadID) {


  uint pID = threadID + u3GroupID.x * NR_THREADS;
  uint bID = pID / _NumVertsPerHair;
  if( pID < _VertBuffer_COUNT && bID < _BaseBuffer_COUNT ){


    pID = safeID( pID , _VertBuffer_COUNT );
    Vert vert = _VertBuffer[pID];
    Base base1 = _BaseBuffer[safeID( bID * 2 + 0 , _BaseBuffer_COUNT )];
    Base base2 = _BaseBuffer[safeID( bID * 2 + 1, _BaseBuffer_COUNT )];

    float l = float(pID % _NumVertsPerHair ) / float(_NumVertsPerHair);
    vert.uv = float2( l , float(bID)/float(_BaseBuffer_COUNT));

    vert.pos = lerp( base1.pos , base2.pos , vert.uv.x );
    vert.oPos = vert.pos;
        
    vert.length = length( base1.pos -base2.pos) * _HairLength;

    _VertBuffer[pID] = vert;

  }
  
}


float3 _PlayerPosition;


[numthreads(NR_THREADS,1,1)]
void Force(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID, uint3 id : SV_DispatchThreadID) {

  //int pID = id.x + id.y * gridX + id.z * gridX * gridY;

  uint pID = threadID + u3GroupID.x * NR_THREADS;
  uint bID = pID / _NumVertsPerHair;

  bool isTip = ((pID % _NumVertsPerHair) == _NumVertsPerHair-1);

 // if( pID < _VertBuffer_COUNT && bID < _BaseBuffer_COUNT ){

    pID = safeID( pID , _VertBuffer_COUNT );
    bID = safeID( bID , _BaseBuffer_COUNT );
   
    Base base1 = _BaseBuffer[bID * 2 + 0];
    Base base2 = _BaseBuffer[bID * 2 + 1];

    float3 bP1 = base1.pos;
    float3 bN1 = base1.nor;

    float3 bP2 = base2.pos;
    float3 bN2 = base2.nor;

    
    Vert vert = _VertBuffer[pID];


    float3 force = 0;
    
    force += float3(0,-4,0);//float3( 0 , base.nor , 0.0 );

    float3 vel = getVel( vert.pos , vert.oPos);

    if( length( force ) > 40 ){
      force = normalize(force) *40;
    }
 
    bool tb = false;


    float3 oP = lerp( base1.pos , base2.pos , vert.uv.x );
    
    // if its screwed up set it proper!
  /*  if( length(vert.pos) == 0 || length(vert.pos.x) == 1000 ){
      vert.pos  = oP;
      vert.oPos = vert.pos;
      tb = true;
    }*/

    // If we are at the bottom, 
    if( vert.uv.x == 0 ){ 
      vert.pos = bP1; 
      vert.oPos = bP1;
      tb = true;
      vert.nor = bN1;

    // if we are at the top
    }else if( vert.uv.x >= 1 - (1/float(_NumVertsPerHair)) ){
      vert.pos = bP2; 
      vert.oPos = bP2;
      tb = true;
      vert.nor = -bN2;
    
    // if we are in between
    }else{
       Vert vDown = _VertBuffer[ safeID( pID - 1 , _VertBuffer_COUNT )];
       vert.nor = normalize(vert.pos - vDown.pos);

       //vert.pos = lerp( base1.pos , base2.pos , vert.uv.x );
    }

    if( _Delta  < .1 && tb == false ){

      float dampening =.9;//_Dampening;//.99999;// - vert.life * .01;
      float3 next = vert.pos + vel  * dampening  + force * .001;

      vert.oPos = vert.pos;
      vert.pos = next;

    }


   _VertBuffer[pID] = vert;




  //}
  
}





float3 getDesiredPosition( int id , Vert v1 ){


    Vert v2 = _VertBuffer[uint(safeID(id,_VertBuffer_COUNT))];

    float3 dif = v1.pos - v2.pos;

    float l = length( dif );// * ((4+n)/4);

    float difference = 0;
    
    // We want to make sure that l isn't zero, 
    // or we will get some NaNs
    if( l > 0.001 ){
        difference = ((_HairLength/float(_NumVertsPerHair))-l)/l;//((s*v1.debug.x/float(_NumVertsPerHair)) - l ) / l;
    }


    // Here is where the actual verlet goes down!
    float3 translate = dif * .5 * difference;

    return translate + v1.pos;
}

[numthreads(NR_THREADS,1,1)]
void Constraint(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID, uint3 id : SV_DispatchThreadID) {
  
  // Get the id using thread / group indices
  uint pID = threadID + u3GroupID.x * NR_THREADS ;

  if( pID < uint(_VertBuffer_COUNT) ){



    pID = uint(safeID(pID,_VertBuffer_COUNT));
    Vert v1 = _VertBuffer[pID];

    float3 newDesiredPosition = 0;
    float totalConnections = 0;

    if( v1.uv.x > 0 ){


        int pID2 = pID-1;
        newDesiredPosition += getDesiredPosition(pID2,v1);
        totalConnections += 1;
    
    }

    if( v1.uv.x <  1-(1/ float(_NumVertsPerHair)) ){
        int pID2 = pID+1;
        newDesiredPosition += getDesiredPosition(pID2,v1);
        totalConnections += 1;

    }

    newDesiredPosition /= totalConnections;
    v1.tan = newDesiredPosition;

    if( v1.uv.x == 0 ){
        v1.tan = v1.pos;
    }

    if( v1.uv.x >=  1-(1/ float(_NumVertsPerHair))){
        v1.tan = v1.pos;
    }

    
    // Set both the values in the proper buffer location!
    //_VertBuffer[ pID ] = v1;

  }



}





[numthreads(NR_THREADS,1,1)]
void Resolve(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID, uint3 id : SV_DispatchThreadID) {
  
  // Get the id using thread / group indices
  uint pID = threadID + u3GroupID.x * NR_THREADS ;

  if( pID < uint(_VertBuffer_COUNT) ){

    pID = uint(safeID(pID,_VertBuffer_COUNT));
    int pUp = uint(safeID(pID+1,_VertBuffer_COUNT));
    Vert v1 = _VertBuffer[pID];
    v1.pos = v1.tan;

    //_VertBuffer[pID] = v1;

  }


}