#pragma kernel SceneCircle
#pragma kernel CircleOnTerrain
#pragma kernel CircleOnTerrainOscillate


#pragma kernel CenterPulse

struct Vert{
  float3 pos;
  float3 vel;
  float3 nor;
  float3 og;
  float2 uv;
  float2 debug;
};



RWStructuredBuffer<Vert> _VertBuffer;

int _VertBuffer_COUNT;

float3 _SetLocation;
float _InnerRadius;
float _OuterRadius;
float _Height;

#include "../Chunks/safeID.cginc"
#include "../Chunks/ComputeTerrainInfo.cginc"
#include "../Chunks/snoise.cginc"




float3 polarToXY( float r , float a ){
  return float3( r * cos(a) ,0, r*sin(a));
}

#define NR_THREADS 128
[numthreads(NR_THREADS,1,1)]
void SceneCircle(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID) {

  int pID = safeID( threadID + u3GroupID.x * NR_THREADS , _VertBuffer_COUNT );

    
    Vert v = _VertBuffer[pID];

 float radius=length(v.og.xz);
 float angle=atan2(v.og.z, v.og.x);

    v.pos = _SetLocation + polarToXY( (radius * (_OuterRadius-_InnerRadius) + _InnerRadius), angle);
    v.pos.y = 0;
    v.nor = -getNormal( v.pos );
    v.pos = worldPos(v.pos) ;
    v.pos += v.nor * .35;

    _VertBuffer[pID] = v;



}


float _Radius;

#define NR_THREADS 128
[numthreads(NR_THREADS,1,1)]
void CircleOnTerrain (uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID) {

  int pID = safeID( threadID + u3GroupID.x * NR_THREADS , _VertBuffer_COUNT );

    
    Vert v = _VertBuffer[pID];

    v.pos = _SetLocation + v.og * _Radius;
    v.pos.y = 0;
    v.nor = getNormal( v.pos );
    v.pos = worldPos(v.pos) ;
    v.pos -= v.nor * _Height;

    _VertBuffer[pID] = v;



}


float _Time;
#define NR_THREADS 128
[numthreads(NR_THREADS,1,1)]
void CircleOnTerrainOscillate (uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID) {

  int pID = safeID( threadID + u3GroupID.x * NR_THREADS , _VertBuffer_COUNT );

    
    Vert v = _VertBuffer[pID];

    v.pos = _SetLocation + v.og * _Radius;
    v.pos.y = 0;

    v.nor = getNormal( v.pos );
    v.pos = worldPos(v.pos) ;
    v.pos -= v.nor * _Height - (snoise(v.pos * .1 + float3(0,_Time * .1,0))+1) * _Height;

    _VertBuffer[pID] = v;



}



#include "../Chunks/GetRayForce.cginc"

float3 _PlayerPosition;

#define NR_THREADS 128
[numthreads(NR_THREADS,1,1)]
void CenterPulse (uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID) {

  int pID = safeID( threadID + u3GroupID.x * NR_THREADS , _VertBuffer_COUNT );

    
    Vert v = _VertBuffer[pID];



    float3 target = _SetLocation + v.og * _Radius;
    target.y = 0;

    v.nor = getNormal( target );
    target = worldPos(target) ;

    float upVal = length(v.og.xz);//(1-length(v.og.xz));
    upVal *= 10;//= 3.14 * 2;
    float yVal = 1*sin(upVal)/upVal + (1-length(v.og.xz)) +  .2 * sin( _Time * 4+length(v.og.xz)*10 + upVal ) * (1-length(v.og.xz));

    if( length(v.og.xz)>.97){ yVal = 0;}

    float3 fHeight=  _Height * yVal * .3;

   float playerD = length(v.pos.xz - _PlayerPosition.xz); 
    fHeight = lerp( fHeight, 0, saturate(1/(1*playerD)) );


    target = target -v.nor * fHeight;
    float3 d = target - v.pos;

    if( length(d) > _Radius ){
      v.pos = target;
      v.vel = 0;
    }
    float3 force = float3(0,0,0);
    force += (target - v.pos) * .02;


    force += GetRayForce( v.pos , 1) * 1 * _DOWN * .005;
    v.vel += force;
    v.pos  += v.vel;

    //v.pos = lerp(v.pos,target,1);

    v.vel *= .97;




    _VertBuffer[pID] = v;



}




