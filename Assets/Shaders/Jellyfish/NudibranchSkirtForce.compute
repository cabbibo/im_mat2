#pragma kernel Force

#include "../Chunks/noise.cginc"
#include "../Chunks/snoise.cginc"
#include "../Chunks/curlNoise.cginc"


float4x4 transform; 

float _Delta;
float _Time;

float3 _HandL;
float3 _HandR;

struct Vert{
  float3 pos;
  float3 oPos;
  float3 nor;
  float3 tan;
  float2 uv;
  float2 connectionInfo;
};


struct Connection{
    float id1;
    float id2;
    float length;
};


float4x4 _Transform;

RWStructuredBuffer<Vert> _VertBuffer;
RWStructuredBuffer<Connection> _ConnectionBuffer;
RWStructuredBuffer<Vert> _SkeletonBuffer;

uint _VertBuffer_COUNT;
uint _ConnectionBuffer_COUNT;
uint _SkeletonBuffer_COUNT;


#include "../Chunks/terrainCompute.cginc"
#include "../Chunks/safeID.cginc"
#include "../Chunks/springForce.cginc"


#define NR_THREADS 128


#include "../Chunks/GetRayForce.cginc"


float3 _PlayerPosition;
int _Rows;
int _Cols;




#include "../Chunks/cubicCurve.cginc"

float3 cubicFromValue( in float val , in int curveLength , out float3 upPos , out float3 doPos){

  float3 p0 = float3( 0. , 0. , 0. );
  float3 v0 = float3( 0. , 0. , 0. );
  float3 p1 = float3( 0. , 0. , 0. );
  float3 v1 = float3( 0. , 0. , 0. );

  float3 p2 = float3( 0. , 0. , 0. );

  float vPP = float(curveLength);

  float base = val * (vPP-1);

  int baseUp   = floor( base );
  int baseDown = ceil( base );
  float amount = base - float(baseUp);


  if( baseUp == 0 ){

    p0 = _SkeletonBuffer[ safeID( baseUp         *2 +1 , _SkeletonBuffer_COUNT) ].pos;
    p1 = _SkeletonBuffer[ safeID( baseDown       *2 +1 , _SkeletonBuffer_COUNT) ].pos;
    p2 = _SkeletonBuffer[ safeID( (baseDown + 1) *2 +1 , _SkeletonBuffer_COUNT) ].pos;

    v1 = .5 * ( p2 - p0 );

  }else if( baseDown == vPP-1 ){

    p0 = _SkeletonBuffer[ safeID( baseUp       *2 +1 , _SkeletonBuffer_COUNT) ].pos;
    p1 = _SkeletonBuffer[ safeID( baseDown     *2 +1 , _SkeletonBuffer_COUNT) ].pos;
    p2 = _SkeletonBuffer[ safeID( (baseUp - 1) *2 +1 , _SkeletonBuffer_COUNT) ].pos;

    v0 = .5 * ( p1 - p2 );

  }else{

    p0 = _SkeletonBuffer[ safeID( baseUp    *2 +1 , _SkeletonBuffer_COUNT) ].pos;
    p1 = _SkeletonBuffer[ safeID( baseDown  *2 +1 , _SkeletonBuffer_COUNT) ].pos;


    float3 pMinus = float3(0,0,0);

    pMinus = _SkeletonBuffer[ safeID( (baseUp   - 1) *2+1 , _SkeletonBuffer_COUNT) ].pos;
    p2 =     _SkeletonBuffer[ safeID( (baseDown + 1) *2+1 , _SkeletonBuffer_COUNT) ].pos;

    v1 = .5 * ( p2 - p0 );
    v0 = .5 * ( p1 - pMinus );

  }

  float3 c0 = p0;
  float3 c1 = p0 + v0/3.;
  float3 c2 = p1 - v1/3.;
  float3 c3 = p1;

  float3 pos = cubicCurve( amount , c0 , c1 , c2 , c3 );

  upPos = cubicCurve( amount  + .01 , c0 , c1 , c2 , c3 );
  doPos = cubicCurve( amount  - .01 , c0 , c1 , c2 , c3 );

  return pos;

}



[numthreads(NR_THREADS,1,1)]
void Force(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID, uint3 id : SV_DispatchThreadID) {

  //int pID = id.x + id.y * gridX + id.z * gridX * gridY;

  uint pID = threadID + u3GroupID.x * NR_THREADS;

 // if( pID < _VertBuffer_COUNT && bID < _BaseBuffer_COUNT ){

    pID = safeID( pID , _VertBuffer_COUNT );

    Vert v = _VertBuffer[pID];

    float3 force = 0;


    force += GetRayForce( v.pos , 2) * .8 * _DOWN;

    v.pos += force * .01;

 
   


 

 float angle = v.uv.x;
 float radius = v.uv.y;



float x = radius * sin(6.28* angle);
float y = radius * cos(6.28* angle);

    float3 upPos;
    float3 doPos;
   


    float3 targetPos = cubicFromValue( y * .45+ .5,120, upPos , doPos);


float3 left = normalize(cross( upPos-targetPos , float3(0,1,0)));



    float3 outVec = left;

    targetPos += outVec * x * 4 * abs(.5-y);




 

  v.pos -= (v.pos - targetPos) * .001;//* (1-v.uv.y);//*(1-v.uv.y);
  //v.pos -= outVec * .1;

//v.pos = targetPos;
//v.oPos = v.pos;
    v.tan = v.pos; 

    _VertBuffer[pID] = v;



}



