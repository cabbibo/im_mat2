#pragma kernel Force

#include "../Chunks/noise.cginc"
#include "../Chunks/snoise.cginc"
#include "../Chunks/curlNoise.cginc"


float4x4 transform; 

float _Delta;
float _Time;

float3 _HandL;
float3 _HandR;

struct Vert{
  float3 pos;
  float3 oPos;
  float3 nor;
  float3 tan;
  float2 uv;
  float2 connectionInfo;
};


struct Connection{
    float id1;
    float id2;
    float length;
};


float4x4 _Transform;

RWStructuredBuffer<Vert> _VertBuffer;
RWStructuredBuffer<Connection> _ConnectionBuffer;
RWStructuredBuffer<Vert> _SkeletonBuffer;

uint _VertBuffer_COUNT;
uint _ConnectionBuffer_COUNT;
uint _SkeletonBuffer_COUNT;


#include "../Chunks/terrainCompute.cginc"
#include "../Chunks/safeID.cginc"
#include "../Chunks/springForce.cginc"


#define NR_THREADS 128


#include "../Chunks/GetRayForce.cginc"


float3 _PlayerPosition;
int _Rows;
int _Cols;

#include "../Chunks/CubicCurveFromSkeletonBuffer.cginc"

[numthreads(NR_THREADS,1,1)]
void Force(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID, uint3 id : SV_DispatchThreadID) {

  //int pID = id.x + id.y * gridX + id.z * gridX * gridY;

  uint pID = threadID + u3GroupID.x * NR_THREADS;

 // if( pID < _VertBuffer_COUNT && bID < _BaseBuffer_COUNT ){

    pID = safeID( pID , _VertBuffer_COUNT );

    Vert v = _VertBuffer[pID];

    float3 force = 0;


    force += GetRayForce( v.pos , 2) * .8 * _DOWN;

    v.pos += force * .01;

 
   

    float3 upPos;
    float3 doPos;
    float3 targetPos = cubicFromValue( v.uv.y * .1+ .01,120, upPos , doPos);

    float3 nor = upPos - doPos;

    if( length(nor) == 0 ){
      nor = float3(0,0,1);
    }else{
      nor = normalize(nor);
    }

    float3 c = cross(nor , float3(0,1,0));
    if( length(c) == 0){
      c = cross(nor , float3(1,0,0));
    }
    float3 x = normalize(c);
    float3 y = normalize(cross(nor,x));


    float angle = v.uv.x * 6.28;

    float3 outVec = x * sin(angle) - y * cos(angle);


float val = v.uv.y;
float radius = lerp( pow(val,.1) , (val*val)*1.2 , val);
 targetPos += outVec *4*radius;

    // If we are at the bottom, 
    if( v.uv.y <.01){ 
        v.pos = mul(_Transform, float4(0,0,0,1) );
        v.oPos = v.pos;
    }

 

  v.pos -= (v.pos - targetPos) * .0003;//* (1-v.uv.y);//*(1-v.uv.y);
  //v.pos -= outVec * .1;

//v.pos = targetPos;
//v.oPos = v.pos;
    v.tan = v.pos; 

    _VertBuffer[pID] = v;



}



