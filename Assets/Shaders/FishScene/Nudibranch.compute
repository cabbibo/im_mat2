#pragma kernel Bounce


struct Vert{
  float3 pos;
  float3 vel;
  float3 nor;
  float3 ogPos;
  float2 uv;
  float debug;
  float life;
};



RWStructuredBuffer<Vert> _VertBuffer;


float4x4 _Transform;

float3 _Target;


int _VertBuffer_COUNT;
int _TransformBuffer_COUNT;

#include "../Chunks/safeID.cginc"
#include "../Chunks/snoise.cginc"
#include "../Chunks/hash.cginc"
#include "../Chunks/curlNoise.cginc"



float _Time;
#include "../Chunks/terrainCompute.cginc"

#define NR_THREADS 128
[numthreads(NR_THREADS,1,1)]
void Bounce(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID) {

  int pID = threadID + u3GroupID.x * NR_THREADS;

  pID = safeID(pID,_VertBuffer_COUNT);
  Vert vert = _VertBuffer[pID];

  if( vert.life == 0 ){ vert.life = hash(float(pID)); }

  if( vert.life <= 0 ){



    vert.pos = mul( _Transform , float4( 0,0,0,1)).xyz;



    float3 up = mul( _Transform ,float4(0,1,0,0)).xyz;
    float3 right = mul( _Transform ,float4(1,0,0,0)).xyz;
    float3 back = mul( _Transform ,float4(0,0,1,0)).xyz;
    vert.pos += up   * ( hash(float(pID * 431)) - .5) * 1;//  * ( hash(float(pID * 31)) - .5) * .2;
    vert.pos += right * ( hash(float(pID * 41)) - .5) * 1;;

    float3 v = float3( hash(float(pID * 20)),hash(float(pID * 42)),hash(float(pID * 32)));
    v -= .5;

    vert.life = 1;// + hash(float(pID));


  }else{


    float3 force = 0;



    float3 worldP = worldPos( vert.pos );
    force -= float3(0,1,0) * .01;


    if( vert.pos.y < worldP.y +.1 ){
        force += float3(0,1,0) * .1;
    }

    float3 d = _Target - vert.pos;

    force += d;

    vert.vel += force;

    vert.pos += vert.vel;

    //vert.tan = normalize(cross( vert.vel , float3(0,1,0)));
    if( vert.life == 1 ){
      vert.life -= .01;
    }


    vert.vel *= .8;//* minDist;

  }

  vert.nor = float3(1,0,0);
  vert.debug = 1;
  
 // vert.nor = mul(rotation(vert.axis,vert.life*20*(hash(float(pID*123)))+hash(float(pID * 23))),float4(0,0,1,0)).xyz;
  
  _VertBuffer[pID] = vert;

}

