#pragma kernel Set
#pragma kernel SetBunch
#pragma kernel Force
#pragma kernel ForceBunch
#pragma kernel ForceBunchLoop
#pragma kernel Constraint
#pragma kernel ConstraintLoop
#pragma kernel Resolve
#pragma kernel PassSafe

#include "../Chunks/noise.cginc"
#include "../Chunks/snoise.cginc"
#include "../Chunks/curlNoise.cginc"


float4x4 transform; 

float _Delta;
float _Time;
uint _Pass;
float _SpringDistance;

uint _NumVertsPerHair;
uint _HairsPerPoint;
float _BunchOutForce;
float _HairLength;
float _UpForce;
float _HairVariance;

uint _HairsPerVert;

float3 _HandL;
float3 _HandR;

struct Vert{
  float3 pos;
  float3 oPos;
  float3 nor;
  float3 tan;
  float2 uv;
  float  length;
  float debug;
};


struct Base{
    float4x4 ltw;
    float4x4 wtl;
};



float _NormalForce;
float _NoiseForce;
float _NoiseSpeed;
float _NoiseSize;
float _Dampening;

RWStructuredBuffer<Vert> _VertBuffer;
RWStructuredBuffer<Base> _BaseBuffer;

uint _VertBuffer_COUNT;
uint _BaseBuffer_COUNT;

RWStructuredBuffer<Vert> _SkeletonBuffer;
uint _SkeletonBuffer_COUNT;



#include "../Chunks/terrainCompute.cginc"


#include "../Chunks/safeID.cginc"


#include "../Chunks/springForce.cginc"


#include "../Chunks/GetRayForce.cginc"

#include "../Chunks/CubicCurveFromSkeletonBuffer.cginc"
float3 _PlayerPosition;

float3 getDelta( float3 p1 , float3 p2 , float dL ){
  
  float3 dif = p1 - p2;
  float l = length( dif );      
  float f = (l - dL) / l;

    if (isnan(f) || isinf(f))
    {
      return (0).xxx;
    }

    return -f * dif * 0.5;

}

float3 getDelta( int id , Vert v1 ){

    Vert v2 = _VertBuffer[id];
    float hairL = v1.length/float(_NumVertsPerHair);

    return getDelta(v1.tan,  v2.tan, hairL);

}




#define NR_THREADS 128


float3 origin( Base b ){
    return mul( b.ltw , float4(0,0,0,1)).xyz;
}

float3 normal( Base b ){
   return normalize( mul( b.ltw , float4(0,0,1,0)).xyz);
}
[numthreads(NR_THREADS,1,1)]
void Set (uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID, uint3 id : SV_DispatchThreadID) {


  uint pID = threadID + u3GroupID.x * NR_THREADS;
  uint bID = pID / _NumVertsPerHair;
 

  if( pID < _VertBuffer_COUNT && bID < _BaseBuffer_COUNT ){


    pID = safeID( pID , _VertBuffer_COUNT );
    Vert vert = _VertBuffer[pID];
    Base base1 = _BaseBuffer[safeID( bID  , _BaseBuffer_COUNT )];

    float l = float(pID % _NumVertsPerHair ) / float(_NumVertsPerHair);
    vert.uv = float2( l , float(bID)/float(_BaseBuffer_COUNT));

    vert.pos = origin(base1) + normal(base1) * vert.uv.x * _HairLength;
    vert.oPos = vert.pos;
    vert.tan = vert.pos;
        
    vert.length = _HairLength;

    _VertBuffer[pID] = vert;

  }
  
}



[numthreads(NR_THREADS,1,1)]
void SetBunch(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID, uint3 id : SV_DispatchThreadID) {


  uint pID = threadID + u3GroupID.x * NR_THREADS;
  uint bID = pID / _NumVertsPerHair;
  uint hairInVert = bID % _HairsPerVert;
  bID /= _HairsPerVert;

  if( pID < _VertBuffer_COUNT && bID < _BaseBuffer_COUNT ){


    pID = safeID( pID , _VertBuffer_COUNT );
    Vert vert = _VertBuffer[pID];
    Base base1 = _BaseBuffer[safeID( bID  , _BaseBuffer_COUNT )];

    float l = float(pID % _NumVertsPerHair ) / float(_NumVertsPerHair);
    vert.uv = float2( l , float(bID)/float(_BaseBuffer_COUNT));

    vert.pos = origin(base1) + normal(base1) * vert.uv.x * _HairLength;
    vert.oPos = vert.pos;
    vert.tan = vert.pos;
        
    vert.length = _HairLength;

    _VertBuffer[pID] = vert;

  }
  
}





[numthreads(NR_THREADS,1,1)]
void Force(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID, uint3 id : SV_DispatchThreadID) {

  //int pID = id.x + id.y * gridX + id.z * gridX * gridY;

  uint pID = threadID + u3GroupID.x * NR_THREADS;
  uint bID = pID / _NumVertsPerHair;


  if( pID < _VertBuffer_COUNT && bID < _BaseBuffer_COUNT ){

    pID = safeID( pID , _VertBuffer_COUNT );
    bID = safeID( bID , _BaseBuffer_COUNT );
   
    Base base1 = _BaseBuffer[bID ];

    float3 bP1 = origin(base1);
    float3 bN1 = normal(base1);

    
    Vert vert = _VertBuffer[pID];

    vert.length = _HairLength;
    
    float l = float(pID % _NumVertsPerHair ) / float(_NumVertsPerHair);
    vert.uv = float2( l , float(bID)/float(_BaseBuffer_COUNT));

    float3 force = 0;
  
    


    // If we are at the bottom, 
    if( vert.uv.x == 0){ 
      vert.pos = bP1 + bN1 * vert.uv.x * _HairLength;
      vert.nor = bN1;
      vert.oPos = vert.pos;
    }else{
      Vert vDown = _VertBuffer[ safeID( pID - 1 , _VertBuffer_COUNT )];
      vert.nor = normalize(vert.pos - vDown.pos); 
    }

    force += GetRayForce( vert.pos , 2) * .8 * _DOWN;

    vert.pos += force * .01;
    

    vert.tan = vert.pos;

    _VertBuffer[pID] = vert;

 }
  
}



[numthreads(NR_THREADS,1,1)]
void ForceBunch(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID, uint3 id : SV_DispatchThreadID) {

  //int pID = id.x + id.y * gridX + id.z * gridX * gridY;

  uint pID = threadID + u3GroupID.x * NR_THREADS;
  uint bID = pID / _NumVertsPerHair;

 uint hairInVert = bID % _HairsPerVert;
  bID /= _HairsPerVert;

  if( pID < _VertBuffer_COUNT && bID < _BaseBuffer_COUNT ){

    pID = safeID( pID , _VertBuffer_COUNT );
    bID = safeID( bID , _BaseBuffer_COUNT );
   
    Base base1 = _BaseBuffer[bID ];

    float3 bP1 = origin(base1);
    float3 bN1 = normal(base1);

    
    Vert vert = _VertBuffer[pID];

    vert.length = _HairLength;
    
    float l = float(pID % _NumVertsPerHair ) / float(_NumVertsPerHair);
    vert.uv = float2( l , float(bID)/float(_BaseBuffer_COUNT));

    float3 force = 0;
  
    
    float3 x = normalize(mul( base1.ltw, float4(1,0,0,0)).xyz);
    float3 y =normalize(mul( base1.ltw, float4(0,1,0,0)).xyz);


    float angle = float(hairInVert)/float(_HairsPerVert) * 6.28;

    float3 outVec = x * sin(angle) - y * cos(angle);

    //force += outVec * .01*vert.uv.x * vert.uv.x;
    //force += -bN1 * .01*vert.uv.x * vert.uv.x;

    int p1= (pID+_NumVertsPerHair )% _VertBuffer_COUNT;
    int p2 =pID-_NumVertsPerHair;
    if( p2 < 0 ){ p2 += _VertBuffer_COUNT; }

    Vert vert1 = _VertBuffer[p1];
    Vert vert2 = _VertBuffer[p2];



    
    force += getDelta(vert.pos , vert1.pos , vert.uv.x * 4 ) * .2;
    force += getDelta(vert.pos , vert2.pos , vert.uv.x * 4 ) * .2;




    float3 upPos;
    float3 doPos;
    float3 targetPos = cubicFromValue( vert.uv.x *.7,120, upPos , doPos);

    float3 nor = upPos - doPos;

    if( length(nor) == 0 ){
      nor = float3(0,0,1);
    }else{
      nor = normalize(nor);
    }

    float3 c = cross(nor , float3(0,1,0));
    if( length(c) == 0){
      c = cross(nor , float3(1,0,0));
    }
    x = normalize(c);
    y = normalize(cross(nor,x));


    

    outVec = x * sin(angle) - y * cos(angle);


float val = vert.uv.x;
float radius = lerp( pow(val,.3) , (val*val)*1.2 , val);
 targetPos += outVec *3*radius;

 

 vert.pos -= (vert.pos - targetPos) * .0003;//* (1-v.uv.y);//*(1-v.uv.y);




    // If we are at the bottom, 
    if( vert.uv.x == 0){ 
      vert.pos = bP1 + bN1 * vert.uv.x * _HairLength;
      vert.nor = bN1;
      vert.oPos = vert.pos;
    }else{
      Vert vDown = _VertBuffer[ safeID( pID - 1 , _VertBuffer_COUNT )];
      vert.nor = normalize(vert.pos - vDown.pos); 
    }

    force += GetRayForce( vert.pos , 2) * .8 * _DOWN;

    vert.pos += force * .01;
    

    vert.tan = vert.pos;

    _VertBuffer[pID] = vert;

 }
  
}



[numthreads(NR_THREADS,1,1)]
void ForceBunchLoop(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID, uint3 id : SV_DispatchThreadID) {

  //int pID = id.x + id.y * gridX + id.z * gridX * gridY;

  uint pID = threadID + u3GroupID.x * NR_THREADS;
  uint bID = pID / _NumVertsPerHair;

 uint hairInVert = bID % _HairsPerVert;
  bID /= _HairsPerVert;

  if( pID < _VertBuffer_COUNT && bID < _BaseBuffer_COUNT ){

    pID = safeID( pID , _VertBuffer_COUNT );
    bID = safeID( bID , _BaseBuffer_COUNT );
   
    Base base1 = _BaseBuffer[bID ];

    float3 bP1 = origin(base1);
    float3 bN1 = normal(base1);

    
    Vert vert = _VertBuffer[pID];

    vert.length = _HairLength;
    
    float l = float(pID % _NumVertsPerHair ) / float(_NumVertsPerHair);
    vert.uv = float2( l , float(bID)/float(_BaseBuffer_COUNT));

    float3 force = 0;

    float loopedUVX = (.5-abs(vert.uv.x - .5)) * 2;
    
  
    
    float3 x = normalize(mul( base1.ltw, float4(1,0,0,0)).xyz);
    float3 y =normalize(mul( base1.ltw, float4(0,1,0,0)).xyz);


    float angle = float(hairInVert)/float(_HairsPerVert) * 6.28;

    float3 outVec = x * sin(angle) - y * cos(angle);

    //force += outVec * .01*vert.uv.x * vert.uv.x;
    //force += -bN1 * .01*vert.uv.x * vert.uv.x;

    int p1= (pID+_NumVertsPerHair )% _VertBuffer_COUNT;
    int p2 =pID-_NumVertsPerHair;
    if( p2 < 0 ){ p2 += _VertBuffer_COUNT; }

    Vert vert1 = _VertBuffer[p1];
    Vert vert2 = _VertBuffer[p2];



    // getting the opposite section in our loop, so we can push against it!
    int p3 = pID - hairInVert * _NumVertsPerHair;
    p3 += _NumVertsPerHair/2;
    p3 %= _NumVertsPerHair;
    p3 += hairInVert * _NumVertsPerHair;


    Vert vert3 = _VertBuffer[p3];

    force += getDelta(vert.pos , vert3.pos , loopedUVX * 1) * .2;

    
    force += getDelta(vert.pos , vert1.pos , loopedUVX * 1) * .2;
    force += getDelta(vert.pos , vert2.pos , loopedUVX * 1) * .2;




    float3 upPos;
    float3 doPos;
    float3 targetPos = cubicFromValue( loopedUVX *.2,120, upPos , doPos);

    float3 nor = upPos - doPos;

    if( length(nor) == 0 ){
      nor = float3(0,0,1);
    }else{
      nor = normalize(nor);
    }

    float3 c = cross(nor , float3(0,1,0));
    if( length(c) == 0){
      c = cross(nor , float3(1,0,0));
    }
    x = normalize(c);
    y = normalize(cross(nor,x));


    

    outVec = x * sin(angle) - y * cos(angle);


float val = loopedUVX;
float radius = lerp( pow(val,.3) , (val*val)*1.2 , val);
 targetPos += outVec *6*radius;

 

 vert.pos -= (vert.pos - targetPos) * .0001;//* (1-v.uv.y);//*(1-v.uv.y);




    // If we are at the bottom, 
    if( vert.uv.x == 0){ 
      vert.pos = bP1 + bN1 * vert.uv.x * _HairLength;
      vert.nor = bN1;
      vert.oPos = vert.pos;
    }else{
      Vert vDown = _VertBuffer[ safeID( pID - 1 , _VertBuffer_COUNT )];
      vert.nor = normalize(vert.pos - vDown.pos); 
    }

    force += GetRayForce( vert.pos , 2) * .8 * _DOWN;

    vert.pos += force * .01;
    

    vert.tan = vert.pos;

    _VertBuffer[pID] = vert;

 }
  
}








[numthreads(NR_THREADS,1,1)]
void Constraint(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID, uint3 id : SV_DispatchThreadID) {
  
  // Get the id using thread / group indices
  uint pID = threadID + u3GroupID.x * NR_THREADS ;

    Vert v = _VertBuffer[pID];


    float3 totalDelta = 0;//float3(0,.0001,0);
    // link above
    if( v.uv.x > 0 ){
        int pID2 = pID-1;
        totalDelta += getDelta(pID2,v);
        v.pos += getDelta(pID2,v);
    }

    // link below
    if( v.uv.x <  1-(1.01/ float(_NumVertsPerHair)) ){
        int pID2 = pID+1;
        totalDelta += getDelta(pID2,v);
       v.pos += getDelta(pID2,v);
    }
    
    if( v.uv.x == 0 ){
        v.pos = v.oPos;
    }

    



    _VertBuffer[ pID ] = v;



}


[numthreads(NR_THREADS,1,1)]
void ConstraintLoop(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID, uint3 id : SV_DispatchThreadID) {
  
  // Get the id using thread / group indices
  uint pID = threadID + u3GroupID.x * NR_THREADS ;

    Vert v = _VertBuffer[pID];


    float3 totalDelta = 0;//float3(0,.0001,0);
    
    // link above
    int pID2 = pID-1;
    if( pID2 < 0 ){ pID2 += _VertBuffer_COUNT; }
    totalDelta += getDelta(pID2,v);
    v.pos += getDelta(pID2,v);

    // link below
    pID2 = pID+1;
    pID2 %= _VertBuffer_COUNT;
    totalDelta += getDelta(pID2,v);
    v.pos += getDelta(pID2,v);

    
    if( v.uv.x == 0 ){
        v.pos = v.oPos;
    }

    _VertBuffer[ pID ] = v;



}












[numthreads(NR_THREADS,1,1)]
void PassSafe(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID, uint3 id : SV_DispatchThreadID) {
  
  // Get the id using thread / group indices
  uint pID = threadID + u3GroupID.x * NR_THREADS ;

  Vert v = _VertBuffer[pID];
  
  v.tan = v.pos;

  _VertBuffer[pID] = v;

}




[numthreads(NR_THREADS,1,1)]
void Resolve(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID, uint3 id : SV_DispatchThreadID) {
  
  // Get the id using thread / group indices
  uint pID = threadID + u3GroupID.x * NR_THREADS ;
  Vert v = _VertBuffer[pID];
  
  float3 vel = v.pos - v.oPos;
  float3 next = v.pos + vel  * .95;
  
  v.oPos = v.pos;
  v.pos = next;

  _VertBuffer[pID] = v;

}